#include <stdio.h>
#include <string.h>


#define STAMP_VALUE         0x5F0A6C39
#define GET_OFFSET(struct_p,child)  (unsigned long int)(&(((struct_p *)0x00000000)->child))

typedef struct _boot0_standard_head_t
{
	unsigned int  jump_instruction;   // one intruction jumping to real code
	unsigned char   magic[8];           // ="eGON.BT0" or "eGON.BT1",  not C-style string.
	unsigned int  check_sum;          // generated by PC
	unsigned int  length;             // generated by PC
	unsigned int  pub_head_size;      // the size of boot_file_head_t
	unsigned char   pub_head_vsn[4];    // the version of boot_file_head_t
	unsigned int  ret_addr;           // the return value
	unsigned int  run_addr;           // run addr
	unsigned char   eGON_vsn[4];        // eGON version
	unsigned char   platform[8];        // platform information
}boot0_standard_head_t;


static int func_checkSum(int *buffer,int length)
{
	int sum = 0;
	int index = 0;
	for(index = 0;index < length;index++)
	{
		sum += buffer[index];
	}
	return sum;
}


int main(int argc,char* argv[])
{
	boot0_standard_head_t boot0_head;
	FILE *input_file;
	FILE *output_file;
	fpos_t input_pos;
	int buffer[256];
	int read_num = 0;
	int write_num = 0;
	int write_total = 0;
	int sum = 0;
	unsigned int headSum_off = 0;
	if(argc != 3)
	{
		printf("input param error! \r\n");
		return -1;
	}
	
	if((input_file = fopen(argv[1],"r")) == NULL)
	{
		printf("cannot find file %s \r\n",argv[1]);
		return -1;
	}
	
	if((output_file = fopen(argv[2],"w+")) == NULL)
	{
		printf("create file %s failed \r\n",argv[2]);
		fclose(input_file);
		return -1;
	}
	
	if(fread(&boot0_head,sizeof(boot0_head),1,input_file) != 1)
	{
		printf("read boot0_head not enough! read_num is %d \r\n",read_num);
		fclose(input_file);
		fclose(output_file);
		return -1;
	}
	
	printf("current magic is %s \r\n",boot0_head.magic);
	printf("STAMP_VALUE is %x \r\n",boot0_head.check_sum);
	printf("current align size is %x \r\n",boot0_head.length);
	fseek(input_file,0,SEEK_END);
	fgetpos(input_file,&input_pos);
	printf("input file size is %ld \r\n",input_pos.__pos);
	
	if(boot0_head.check_sum != STAMP_VALUE)
	{
		printf("STAMP_VALUE check failed !\r\n");
		fclose(input_file);
		fclose(output_file);
		return -1;
	}
	
	if(boot0_head.length < input_pos.__pos)
	{
		printf("boot0_head.length too low! \r\n");
		fclose(input_file);
		fclose(output_file);
		return -1;
	}
	rewind(input_file);
	rewind(output_file);
	memset(buffer,0x0,sizeof(buffer));
	while((read_num = fread(buffer,1,sizeof(buffer),input_file)) > 0)
	{
			fwrite(buffer,sizeof(char),read_num,output_file);
			write_total += read_num;
			sum += func_checkSum(buffer,read_num/sizeof(buffer[0]));
			printf("copy file %d bytes \r\n",write_total);
			memset(buffer,0x0,sizeof(buffer));
	}
	
	if(write_total != input_pos.__pos)
	{
		printf("write error ! \r\n");
	}
	
	if(boot0_head.length > write_total)
	{
		printf("need add %d bytes 0x0 to the end of %s !! \r\n",boot0_head.length - write_total,argv[2]);
		fseek(output_file,0,SEEK_END);
		memset(buffer,0x0,sizeof(buffer));
		while(1)
		{
			write_num = ((boot0_head.length - write_total) > sizeof(buffer))?sizeof(buffer):(boot0_head.length - write_total);
			fwrite(buffer,1,write_num,output_file);
			write_total +=write_num;
			if(write_total == boot0_head.length)
				break;
		}
	}
	headSum_off = GET_OFFSET(boot0_standard_head_t,check_sum);
	printf("mkboot0 success\r\n write to %s total %d bytes ,check_sum is %x \r\n",argv[2],write_total,sum);
	fseek(output_file,headSum_off,SEEK_SET);
	fwrite(&sum,sizeof(int),1,output_file);
	fclose(input_file);
	fclose(output_file);
	return 0;
}